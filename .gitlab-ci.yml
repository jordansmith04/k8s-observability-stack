# Gitlab CI/CD pipeline for provisioning EKS and deploying the Observability Stack

default:
  before_script:
    # Install utilities, AWS CLI, and Helm
    - apk update && apk add gettext bash curl unzip jq python3 py3-pip
    - pip install awscli
    # Ensure AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are set as CI/CD variables.

variables:
  # Terraform State Management
  TF_ADDRESS: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${CI_PROJECT_NAME}

  # AWS/EKS Variables
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: obs-demo-cluster
  K8S_NAMESPACE: k8s-obs-stack

stages:
  - validate
  - provision
  - deploy

# Terraform validate
terraform_validate:
  stage: validate
  image: registry.gitlab.com/gitlab-org/terraform-images/stable:latest
  script:
    - echo "Running Terraform validation in the 'terraform/' directory..."
    - cd terraform # Change directory to where main.tf resides
    - terraform init
    - terraform validate
  allow_failure: false # Validation must pass to proceed

# Terraform apply
terraform_provision:
  stage: provision
  image: registry.gitlab.com/gitlab-org/terraform-images/stable:latest
  script:
    - echo "Running Terraform provisioning in the 'terraform/' directory..."
    - cd terraform # Change directory to where main.tf resides
    - terraform init -backend-config="address=${TF_ADDRESS}"
    - terraform plan -out="plan.tfplan"
    - terraform apply -auto-approve "plan.tfplan"

    # Move back to root to ensure kubeconfig is saved in CI_PROJECT_DIR
    - cd ${CI_PROJECT_DIR}

    # Generate kubeconfig for EKS cluster
    - echo "Generating kubeconfig file..."
    - |
      aws eks update-kubeconfig \
        --name ${EKS_CLUSTER_NAME} \
        --region ${AWS_REGION} \
        --kubeconfig kubeconfig.yml

    - echo "Kubeconfig generated successfully."

  artifacts:
    expire_in: 1 hour
    paths:
      - kubeconfig.yml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# Deploy Observability Stack and Microservice
helm_deploy:
  stage: deploy
  image: alpine/helm:3.14.0 # Includes kubectl and Helm
  needs:
    - job: terraform_provision
      artifacts: true

  script:
    - export KUBECONFIG=${CI_PROJECT_DIR}/kubeconfig.yml
    - echo "KUBECONFIG set. Current Kubernetes context:"
    - kubectl config current-context

    # Prepare Environment
    - echo "Creating Namespace: ${K8S_NAMESPACE}"
    - kubectl create namespace ${K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -

    # Add Helm Repositories
    - echo "Adding Helm repositories..."
    - helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    - helm repo add grafana https://grafana.github.io/helm-charts
    - helm repo update

    # Deploy Loki
    - echo "Deploying Loki with custom values from loki/..."
    - helm upgrade --install loki grafana/loki \
        --namespace ${K8S_NAMESPACE} \
        -f loki/values.yaml \
        --atomic

    #Deploy Prometheus Stack
    - echo "Deploying Prometheus Stack with custom values from prometheus/..."
    - helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
        --namespace ${K8S_NAMESPACE} \
        -f prometheus/prometheus-values.yaml \
        --atomic

    # Apply Promtail DaemonSet and ConfigMap
    - echo "Applying custom Promtail manifests from loki/..."
    # Note: These are applied directly with kubectl since they are custom manifests
    - kubectl apply -n ${K8S_NAMESPACE} -f loki/promtail-configmap.yaml
    - kubectl apply -n ${K8S_NAMESPACE} -f loki/promtail-daemonset.yaml

    # Apply Custom Grafana Dashboard ConfigMap
    - echo "Applying custom Grafana dashboard configmap from grafana/..."
    - kubectl apply -n ${K8S_NAMESPACE} -f grafana/grafana-dashboard-configmap.yaml

    # Deploy Nginx Microservice
    - echo "Deploying Nginx Microservice (using local chart ./nginx)..."
    - helm upgrade --install nginx-microservice ./nginx \
        --namespace default \
        --atomic

    - echo "All services deployed successfully."

  rules:
    - if: $CI_COMMIT_BRANCH == "main"